# Local Development Setup

This directory contains configuration for running the NATS K8s OIDC auth callout service locally using Docker Compose.

## Prerequisites

- Docker and Docker Compose installed
- `nsc` CLI tool installed (for generating signing keys)
- Access to a Kubernetes cluster (for obtaining JWKS and testing with real tokens)

### Installing NSC

```bash
# macOS
brew install nsc

# Linux
curl -L https://github.com/nats-io/nsc/releases/latest/download/nsc-linux-amd64.zip -o nsc.zip
unzip nsc.zip && sudo mv nsc /usr/local/bin/ && chmod +x /usr/local/bin/nsc
```

## Quick Start

### 1. Run Setup Script

The setup script generates a NATS account signing key and configures the NATS server:

```bash
cd local-dev
./setup.sh
```

This will:
- Generate an account signing key (`signing.key`)
- Update NATS server configuration with the correct issuer public key
- Show warnings if kubeconfig.yaml or jwks.json are missing

### 2. Obtain Kubernetes Configuration

You need JWKS and kubeconfig from a Kubernetes cluster:

```bash
# Get JWKS (for JWT validation)
kubectl get --raw /openid/v1/jwks > local-dev/jwks.json

# Get kubeconfig (for ServiceAccount cache)
kubectl config view --minify --flatten > local-dev/kubeconfig.yaml
```

### 3. Start Services

```bash
# From project root
docker-compose up --build
```

This starts:
- **NATS server** on port 4222 (client) and 8222 (monitoring)
- **Auth callout service** on port 8080 (health/metrics)

### 4. Verify Services

```bash
# Check NATS server
curl http://localhost:8222/varz

# Check auth service health
curl http://localhost:8080/health

# Check auth service metrics
curl http://localhost:8080/metrics
```

## Authentication Architecture

### NATS Connection Authentication

The auth callout service uses **username/password** authentication (simplest mode for local dev):

```
NATS_URL=nats://auth-service:auth-password@nats:4222
```

This is configured in:
- `docker-compose.yml`: Service environment variable
- `nats-server.conf`: NATS server user definition

### Authorization Signing

The service signs authorization response JWTs using an **account signing key**:

```
NATS_SIGNING_KEY_FILE=/etc/nats/signing.key
```

The signing key format:
```
SAADGYQZI2OIVEXAMPLE...
```

This key is generated by `setup.sh` and must match the `issuer` in `nats-server.conf`.

## Testing with Real Clients

### Create ServiceAccount in Kubernetes

```bash
kubectl create sa test-service
kubectl annotate sa test-service \
  nats.io/allowed-pub-subjects="test.>" \
  nats.io/allowed-sub-subjects="test.>"
```

### Get ServiceAccount Token

```bash
kubectl create token test-service --audience=nats
```

### Connect with NATS CLI

```bash
# Install nats CLI
go install github.com/nats-io/natscli/nats@latest

# Connect using the JWT token
export TOKEN=$(kubectl create token test-service --audience=nats)
nats --server=localhost:4222 --token="$TOKEN" pub test.hello "Hello World"
```

## File Structure

```
local-dev/
├── README.md                 # This file
├── setup.sh                  # Setup script (generates keys)
├── nats-server.conf          # NATS server configuration
├── signing.key               # Account signing key (generated)
├── kubeconfig.yaml           # Kubernetes config (you provide)
└── jwks.json                 # JWKS for JWT validation (you provide)
```

## Configuration Reference

### Environment Variables (docker-compose.yml)

#### NATS Connection
- `NATS_URL`: NATS server URL (with embedded credentials)
- `NATS_SIGNING_KEY_FILE`: Path to account signing key

#### Alternative NATS Authentication Modes

For production-like testing, you can use credentials files:

```yaml
environment:
  NATS_URL: "nats://nats:4222"
  NATS_USER_CREDS_FILE: "/etc/nats/user.creds"
  NATS_SIGNING_KEY_FILE: "/etc/nats/signing.key"
```

#### Kubernetes Configuration
- `JWKS_PATH`: Path to JWKS file for JWT validation
- `JWT_ISSUER`: Expected JWT issuer claim
- `JWT_AUDIENCE`: Expected JWT audience claim (default: "nats")
- `K8S_IN_CLUSTER`: false (out-of-cluster mode)
- `KUBECONFIG`: Path to kubeconfig file

#### Logging
- `LOG_LEVEL`: Logging verbosity (debug, info, warn, error)

## Troubleshooting

### Auth Service Fails to Start

**Error: "failed to load signing key"**
- Run `./setup.sh` to generate signing.key
- Verify signing.key exists and contains a valid seed (starts with SA...)

**Error: "failed to connect to NATS"**
- Check NATS container is running: `docker-compose ps`
- Verify NATS server logs: `docker-compose logs nats`
- Ensure NATS_URL credentials match nats-server.conf users

**Error: "failed to fetch JWKS"**
- Ensure jwks.json exists and contains valid JWKS
- Extract from cluster: `kubectl get --raw /openid/v1/jwks > local-dev/jwks.json`

### Client Connection Fails

**Error: "authorization failed"**
- Check auth service logs: `docker-compose logs auth-service`
- Verify JWT token is valid and has correct audience ("nats")
- Ensure ServiceAccount exists with proper annotations

**Error: "connection timeout"**
- NATS server may not be configured correctly
- Check issuer in nats-server.conf matches signing key public key
- Verify auth_users includes "auth-service"

### View Logs

```bash
# All services
docker-compose logs -f

# Auth service only
docker-compose logs -f auth-service

# NATS server only
docker-compose logs -f nats
```

## Clean Up

```bash
# Stop services
docker-compose down

# Remove generated files
rm -f local-dev/signing.key
```

## Production Differences

This local setup uses simplified authentication for development. In production:

1. **NATS Authentication**: Use proper user credentials files instead of URL-embedded passwords
2. **Signing Key**: Store signing key in Kubernetes Secret, not plain file
3. **JWKS**: Use in-cluster JWKS endpoint (https://kubernetes.default.svc/openid/v1/jwks)
4. **Kubernetes Client**: Use in-cluster config (K8S_IN_CLUSTER=true)
5. **TLS**: Enable TLS for NATS connections

See `docs/DEPLOY.md` for production deployment guide.
