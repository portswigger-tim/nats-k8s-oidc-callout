# Breaking Changes - v2.0.0

## Summary

Version 2.0.0 fixes a fundamental design flaw in NATS authentication configuration. The previous single-file approach (`NATS_CREDS_FILE`) attempted to serve two incompatible purposes:
1. Authenticating the auth service to NATS (requires user key)
2. Signing authorization responses (requires account key)

This created an impossible configuration where no single credentials file could satisfy both requirements.

## What Changed

### Configuration Variables

**Removed:**
- `NATS_CREDS_FILE` - Removed due to conflicting dual-purpose usage

**Added:**
- `NATS_USER_CREDS_FILE` (optional) - User credentials for NATS connection authentication
- `NATS_TOKEN` (optional) - Token-based NATS authentication
- `NATS_SIGNING_KEY_FILE` (required) - Account signing key for authorization responses

### Authentication Architecture

The new architecture cleanly separates two concerns:

**1. NATS Connection Authentication** (How the service connects to NATS):
- **Option A**: URL-embedded credentials `nats://user:pass@host:port` (simplest for dev)
- **Option B**: User credentials file via `NATS_USER_CREDS_FILE` (production)
- **Option C**: Token authentication via `NATS_TOKEN`

**2. Authorization Signing** (How the service signs auth responses):
- **Always**: Account signing key via `NATS_SIGNING_KEY_FILE` (required)

## Migration Guide

### Before (v1.x - Broken Configuration)

```bash
# This configuration never worked correctly
NATS_CREDS_FILE=/etc/nats/auth.creds
NATS_ACCOUNT=AUTH_ACCOUNT
```

The `auth.creds` file generated by `nsc generate creds` contains:
- User JWT + User private key (SU...)
- ✅ Works for NATS connection
- ❌ **Fails** for signing authorization responses (needs account key SA...)

### After (v2.0 - Simple Development Setup)

```bash
# Local development with URL-embedded authentication
NATS_URL=nats://auth-service:password@localhost:4222
NATS_SIGNING_KEY_FILE=/etc/nats/signing.key
NATS_ACCOUNT=AUTH_ACCOUNT
```

**Signing key file format** (`signing.key`):
```
SAADGYQZI2OIVEXAMPLE...
```

Just the account private key (starts with `SA...`) on a single line.

### After (v2.0 - Production Setup)

```bash
# Production with proper user credentials
NATS_URL=nats://nats:4222
NATS_USER_CREDS_FILE=/etc/nats/user.creds
NATS_SIGNING_KEY_FILE=/etc/nats/signing.key
NATS_ACCOUNT=AUTH_ACCOUNT
```

**User credentials file** (`user.creds`):
```
-----BEGIN NATS USER JWT-----
<user-jwt>
------END NATS USER JWT------

-----BEGIN USER NKEY SEED-----
SU...  (user private key)
------END USER NKEY SEED------
```

**Signing key file** (`signing.key`):
```
SAADGYQZI2OIVEXAMPLE...
```

## Generating Keys with NSC

### 1. Generate Account Signing Key

```bash
# Create account
nsc add account AUTH_ACCOUNT

# Extract account signing key
nsc describe account AUTH_ACCOUNT --json | jq -r '.nats.signing_keys[0]' > signing.key

# If signing_keys is empty, use the account key itself
ACCOUNT_KEY_FILE="$NSC_HOME/nats/<operator>/accounts/AUTH_ACCOUNT/AUTH_ACCOUNT.nk"
cat "$ACCOUNT_KEY_FILE" > signing.key

# Get the public key (for NATS server configuration)
ACCOUNT_PUB=$(nsc describe account AUTH_ACCOUNT --json | jq -r '.sub')
echo "Account public key: $ACCOUNT_PUB"
```

### 2. (Optional) Generate User Credentials for Production

```bash
# Create user in the auth account
nsc add user --account AUTH_ACCOUNT auth-service

# Generate user credentials file
nsc generate creds --account AUTH_ACCOUNT --name auth-service > user.creds
```

## Local Development Quick Start

See `local-dev/README.md` for a complete Docker Compose setup.

**Quick steps:**
```bash
cd local-dev
./setup.sh           # Generates signing key and configures NATS
docker-compose up    # Starts NATS + auth service
```

## Why This Change Was Necessary

### The Original Problem

The NATS auth callout library (`synadia-io/callout.go`) validates that the signing key is an **account private key** (starts with `SA...`), not a user key (starts with `SU...`):

```go
// From synadia-io/callout.go
if keyType != nkeys.PrefixByteAccount {
    return nil, fmt.Errorf("response signer key must be an account private key")
}
```

However, standard NATS user credentials files generated by `nsc generate creds` contain:
- User JWT (for authentication)
- User private key (SU...) (for signing the authentication nonce)

This creates an impossible situation where:
- Using a user credentials file → ✅ NATS connection works, ❌ Auth signing fails
- Using an account key in the file → ❌ NATS connection fails, ✅ Auth signing works

### The Solution

Separate the two concerns:
1. **Connection authentication** - Multiple options (URL auth, user creds, token)
2. **Authorization signing** - Always use separate account signing key file

This matches how other NATS tools handle similar requirements and provides a clean, testable architecture.

## Testing

### Unit Tests
```bash
make test
```

### E2E Tests
```bash
make test-e2e
```

The E2E tests now correctly demonstrate the proper configuration.

### Local Docker Testing
```bash
cd local-dev
./setup.sh
docker-compose up
```

## Rollback Instructions

If you need to rollback to v1.x:

```bash
git checkout v1.x.x
docker build -t nats-k8s-oidc-callout:v1.x.x .
```

Note: v1.x had the broken dual-purpose credentials file configuration and would not work correctly in production environments.

## Support

For questions or issues:
- GitHub Issues: https://github.com/portswigger-tim/nats-k8s-oidc-callout/issues
- NATS Slack: #auth-callout channel

## Related Documentation

- `local-dev/README.md` - Local development setup
- `docs/OPERATOR_SETUP.md` - Production operator mode setup
- `docs/DEPLOY.md` - Kubernetes deployment guide
